{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NeXus azint writer","text":"<p><code>azint-writer</code> is a Python package for writing HDF5 files in the NXazint1d or NXazint2d format, a new extension to the NeXus standard. The NXazint1d (NXazint2d) format is specifically designed for storing data related to azimuthal integration in diffraction experiments.</p> <p>Note: The azint-writer package is currently coupled to the <code>azint</code> library for performing azimuthal integration.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>HDF5 File Writing: Easily generate NeXus-compliant HDF5 files.</li> <li>azint-writer Format: Supports the new azint-writer format for azimuthal integration.</li> <li>Customizable Configuration: Flexible options for writing metadata and experimental data.</li> <li>Seamless Integration: Compatible with existing NeXus tools and libraries.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install azint-writer via <code>conda</code>:</p> <pre><code>conda install -c maxiv azint-writer\n</code></pre>"},{"location":"#azint-writer-format","title":"azint-writer Format","text":"<ul> <li>Experiment Metadata: Beamline details, sample information, and experimental setup.</li> <li>Azimuthal Integration Data: One-dimensional and two-dimensional (cake) integration results.</li> <li>Calibration Information: Detector geometry and calibration parameters.</li> </ul> <p>For more information about the NeXus standard, see the official documentation.</p>"},{"location":"#example-usage","title":"Example Usage","text":"<p>Here is a sample Python snippet using azint-writer: (link to file examples and output)</p> <pre><code>import azint, azint_writer, h5py\nimport numpy as np\n\n# Open the HDF5 file containing detector data\nh5name = \"scan-1737_pilatus.h5\"\nh = h5py.File(h5name, 'r')\n# Read the first image frame from the dataset\nimg = h['/entry/instrument/pilatus/data'][10]\n# Specify the PONI file (detector geometry calibration)\nponi = 'Si_135mm.poni'\n# Create a mask with the same shape as the image\nmask = 'hot_px_bs_mask.npy'\n\n\n# Configuration for the azimuthal integration\nconfig = {\n    'poni': poni,                      # Path to the PONI file\n    'mask': mask,                      # Mask to ignore bad pixels\n    'radial_bins': 3000,               # Number of radial bins for integration\n    'azimuth_bins': 180, # or None     # Number of azimuthal bins (for 2D integration)\n    'n_splitting': 21,                 # Number of subdivisions per pixel (for precision)\n    'error_model': 'poisson',          # Error propagation model\n    'solid_angle': True,               # Apply solid angle correction\n    'polarization_factor': 0.965,      # Correction for polarization effects\n    'normalized': True,                # Normalize the output intensities\n    'unit': '2th',                     # Output units (e.g., 2\u03b8)\n}\n# Create the azimuthal integrator instance using azint\nai = azint.AzimuthalIntegrator(**config)\n# Perform the azimuthal integration on the image\ndata = ai.integrate(img)\n\n\n# Configuration for the NXWriter (NeXus HDF5 file writer)\ninit_writer_config = {\n    'ai': ai,                          # AzimuthalIntegrator instance\n    'output_file': 'nx_azint1d_azint2d.h5',     # Output file name\n    'write_1d': True,                  # Whether to write 1D integration data\n    'write_2d': True,                  # Whether to write 2D (cake) integration data (None if azimuth_bins is None)\n    'instrument_name': 'DanMAX',       # Name of the beamline or instrument\n    'source_name': 'MAX IV',           # Name of the facility or source\n    'source_type': 'Synchrotron X-ray Source',  # Type of source\n    'source_probe': 'X-ray',           # Type of probe used (e.g., x-ray, neutron)\n}\n# Create the NXWriter instance and write the data to the file\nnx = azint_writer.NXWriter(**init_writer_config)\n# Add the integrated data to the file\nnx.add_data(data)  \n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome and encourage contributions to azint-writer! Here's how you can get involved:</p> <ul> <li>Fork the repository.</li> <li>Create a new branch for your feature or bug fix.</li> <li>Submit a pull request with a clear and concise description of your changes.</li> </ul> <p>Please make sure your contributions follow the NeXus standard guidelines, especially when adding features related to <code>azint-writer</code>.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License. See the LICENSE file on GitHub for details.</p>"},{"location":"#support","title":"Support","text":"<p>If you encounter any issues, have questions, or would like to suggest improvements, feel free to open an issue on the project\u2019s GitHub issue tracker.</p>"},{"location":"class-reference/","title":"azint_writer","text":""},{"location":"class-reference/#azint_writer.azint_writer.NXWriter","title":"<code>NXWriter</code>","text":"<p>NXWriter class for writing azimuthal integration data to NeXus HDF5 files. This class handles the creation of the NeXus hierarchy, including metadata such as instrument configuration, source details, monochromator properties, and integration parameters. It supports both 1D and 2D data formats, allowing for flexible data storage and retrieval.</p> <p>Attributes:</p> Name Type Description <code>-</code> <code>ai</code> <p>Azimuthal integrator object (should contain integration results and parameters)</p> <code>-</code> <code>output_file (str</code> <p>Path to output HDF5 file</p> <code>-</code> <code>write_1d (bool</code> <p>Whether to include 1D data in the file</p> <code>-</code> <code>write_2d (bool</code> <p>Whether to include 2D data in the file</p> <code>-</code> <code>instrument_name (str</code> <p>Name of the instrument</p> <code>-</code> <code>source_name (str</code> <p>Name of the source</p> <code>-</code> <code>source_type (str</code> <p>Type of the source (e.g., 'Synchrotron')</p> <code>-</code> <code>source_probe (str</code> <p>Type of probe (e.g., 'x-ray')</p> <p>Methods:</p> Name Description <code>- write_header</code> <p>Creates and writes the NeXus hierarchy for the dataset, including metadata such as instrument configuration, source details, monochromator properties, and integration parameters.</p> <code>- add_data</code> <p>Adds azimuthal integration data to the HDF5 file under the proper NXdata group.</p> <code>- write_radial_axis</code> <p>Writes radial axis information to the specified group.</p> Source code in <code>azint_writer/azint_writer.py</code> <pre><code>class NXWriter:\n    \"\"\"\n    NXWriter class for writing azimuthal integration data to NeXus HDF5 files.\n    This class handles the creation of the NeXus hierarchy, including metadata\n    such as instrument configuration, source details, monochromator properties,\n    and integration parameters. It supports both 1D and 2D data formats, allowing\n    for flexible data storage and retrieval.\n\n    Attributes:\n        - ai: Azimuthal integrator object (should contain integration results and parameters)\n        - output_file (str): Path to output HDF5 file\n        - write_1d (bool): Whether to include 1D data in the file\n        - write_2d (bool): Whether to include 2D data in the file\n        - instrument_name (str): Name of the instrument\n        - source_name (str): Name of the source\n        - source_type (str): Type of the source (e.g., 'Synchrotron')\n        - source_probe (str): Type of probe (e.g., 'x-ray')\n\n    Methods:\n        - write_header: Creates and writes the NeXus hierarchy for the dataset,\n          including metadata such as instrument configuration, source details,\n          monochromator properties, and integration parameters.\n        - add_data: Adds azimuthal integration data to the HDF5 file under the\n          proper NXdata group.\n        - write_radial_axis: Writes radial axis information to the specified group.\n    \"\"\"\n\n    def __init__(\n        self, \n        ai, \n        output_file,\n        write_1d=True, \n        write_2d=True, \n        instrument_name=None, \n        source_name=None, \n        source_type=None, \n        source_probe=None\n    ):\n        self.ai = ai\n        self.output_file = output_file\n        self.write_1d = write_1d\n        self.write_2d = write_2d\n        self.instrument_name = instrument_name\n        self.source_name = source_name\n        self.source_type = source_type\n        self.source_probe = source_probe\n\n        with h5py.File(self.output_file, \"w\") as fh_w:\n            self.fh = fh_w\n            if \"entry\" not in fh_w: # this condition can be omitted, check that\n                self.write_header()\n\n    def write_header(self):\n        \"\"\"\n        Creates and writes the NeXus hierarchy for the dataset,\n        including metadata such as instrument configuration, \n        source details, monochromator properties, and integration parameters.\n\n        This method will automatically determine what type(s) of data \n        (1D/2D) are to be written and populate corresponding subentries.\n        \"\"\"\n        logging.info(f\"writing header started, azint version is {azint.__version__}\")\n\n        entry = self.fh.create_group(\"entry\", track_order=True)\n        entry.attrs[\"NX_class\"] = \"NXentry\"\n        entry.attrs[\"default\"] = \"data\" \n        logging.debug(\"entry is created in the file\")\n\n\n        if not (self.write_1d and self.write_2d):\n            logging.info(f\"Creating {'NXazint1d' if self.write_1d else 'NXazint2d'}\")\n            definition = entry.create_dataset(\"definition\", data='NXazint1d' if self.write_1d else 'NXazint2d')       \n\n        solid_angle = entry.create_dataset(\"solid_angle_applied\", data=True if self.ai.solid_angle else False)\n\n        polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n        polarization_applied = entry.create_dataset(\"polarization_applied\", data=True if self.ai.polarization_factor  is not None else False)\n\n        normalization = entry.create_dataset(\"normalization_applied\", data=True if self.ai.normalized else False)\n\n        logging.info(\"solid_angle_applied and polarization_applied data sets are created\")\n        logging.info(f\"solid_angle: {self.ai.solid_angle}\")\n        logging.info(f\"polarization_factor: {self.ai.polarization_factor}\")\n\n\n        # Add instrument\n        instrument = entry.create_group(\"instrument\", track_order=True)\n        instrument.attrs[\"NX_class\"] = \"NXinstrument\"\n        instrument.attrs[\"default\"] = \"name\" \n        logging.info(f\"Instrument: {self.instrument_name}\")\n\n        instrument[\"name\"] = np.string_(self.instrument_name)\n\n        # Add monochromator\n        mono = instrument.create_group(\"monochromator\", track_order=True)\n        mono.attrs[\"NX_class\"] = \"NXmonochromator\"\n        mono.attrs[\"default\"] = \"energy\"  \n\n        # Add source\n        source = instrument.create_group(\"source\", track_order=True)\n        source.attrs[\"NX_class\"] = \"NXsource\"\n        source.attrs[\"default\"] = \"name\" \n        source['name'] = self.source_name\n        source['type'] = self.source_type\n        source['probe'] = self.source_probe\n\n        poni_file = self.ai.poni\n        if isinstance(self.ai.poni, str):\n            with open(poni_file, \"r\") as pf:\n                try:\n                    logging.info(f\"Reading poni file ...\")\n                    ponif = pf.read()\n                    wavelength_found = False\n                    for line in ponif.splitlines():\n                        if line.startswith(\"Wavelength:\"):\n                            wlength_str = line.split(\":\")[1].strip()\n                            try:\n                                wlength = float(wlength_str)\n                                logging.info(f\"From poni file: wavelength: {wlength * 1e10} \u212b\")\n                                wavelength_found = True\n                            except ValueError as e:\n                                logging.error(f\"Error converting wavelength to float: {e}\")\n                                wlength = None\n                            break\n                    if not wavelength_found:\n                        logging.error(\"Wavelength not found in poni file.\")\n                        wlength = None\n                except Exception as e:\n                    logging.error(f\"Cannot open poni file: {e}\")\n        elif isinstance(self.ai.poni, dict):\n            ponif = \"\\n\".join(f\"{key}: {value}\" for key, value in self.ai.poni.items())\n            wavelength_found = False\n            try:\n                wlength = float(self.ai.poni['wavelength'])\n                logging.info(f\"From poni file: wavelength: {wlength * 1e10} \u212b\")\n                wavelength_found = True\n            except ValueError as e:\n                logging.error(f\"Error converting wavelength to float: {e}\")\n                wlength = None\n            if not wavelength_found:\n                logging.error(\"Wavelength not found in poni dict.\")\n                wlength = None\n        else:\n            logging.error(\"Provided format for poni is wrong.\")\n\n        # Now handle data splitting\n        if (self.write_1d and self.write_2d):\n            logging.info(f\"Creating 1D and 2D data ...\")\n            if self.ai.azimuth_axis is None:\n                logging.error(\"2d data is not available.\")\n            # 1D data subentry\n            azint1dSE = entry.create_group(\"azint1d\", track_order=True)\n            azint1dSE.attrs[\"NX_class\"] = \"NXsubentry\"\n\n            definition = azint1dSE.create_dataset(\"definition\", data=\"NXazint1d\")\n\n            azint1dSE[\"instrument\"] = h5py.SoftLink('/entry/instrument')\n\n            reduction = azint1dSE.create_group(\"reduction\", track_order=True)\n            reduction.attrs[\"NX_class\"] = \"NXprocess\"\n            prog = reduction.create_dataset(\"program\", data=\"azint\")\n            ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n            date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n            ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n            note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n            input = reduction.create_group(\"input\", track_order=True)\n            input.attrs[\"NX_class\"] = \"NXparameters\"\n            dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n            dset.attrs[\"filename\"] = poni_file if isinstance(self.ai.poni, str) else \"Poni dict.\"\n\n            wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n            wavelength.attrs[\"units\"] = \"angstrom\"\n            energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n            energy.attrs[\"units\"] = \"keV\"\n\n            wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)\n            wavelength2.attrs[\"units\"] = \"angstrom\"\n\n            input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n            input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n            input.create_dataset(\"azimuth_bins\", data=1)\n            input.create_dataset(\"unit\", data=self.ai.unit)    \n            input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n            input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n            polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n            input.create_dataset(\"polarization_factor\", data=polarization)\n            error_model = self.ai.error_model if self.ai.error_model else \"None\"\n            input.create_dataset(\"error_model\", data=error_model)\n\n\n            azint1d = azint1dSE.create_group(\"data\")\n            azint1d.attrs[\"NX_class\"] = \"NXdata\"\n            azint1d.attrs[\"signal\"] = \"I\"\n            azint1d.attrs[\"axes\"] = [\".\", \"radial_axis\"]\n            azint1d.attrs[\"interpretation\"] = \"spectrum\"\n            self.write_radial_axis(azint1d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n\n            azint2dSE = entry.create_group(\"azint2d\", track_order=True)\n            azint2dSE.attrs[\"NX_class\"] = \"NXsubentry\"\n\n            definition = azint2dSE.create_dataset(\"definition\", data=\"NXazint2d\")\n\n            azint2dSE[\"instrument\"] = h5py.SoftLink('/entry/instrument')\n\n            reduction = azint2dSE.create_group(\"reduction\", track_order=True)\n            reduction.attrs[\"NX_class\"] = \"NXprocess\"\n            prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n            ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n            date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n            ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n            note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n            input = reduction.create_group(\"input\", track_order=True)\n            input.attrs[\"NX_class\"] = \"NXparameters\"\n\n            wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)\n            wavelength2.attrs[\"units\"] = \"angstrom\"\n\n            input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n            input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n            input.create_dataset(\"azimuth_bins\", data=self.ai.azimuth_bins)\n            input.create_dataset(\"unit\", data=self.ai.unit)\n            input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n            input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n            polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n            input.create_dataset(\"polarization_factor\", data=polarization)\n            error_model = self.ai.error_model if self.ai.error_model else \"None\"\n            input.create_dataset(\"error_model\", data=error_model)\n\n            azint2d = azint2dSE.create_group(\"data\")\n            azint2d.attrs[\"NX_class\"] = \"NXdata\"\n            azint2d.attrs[\"signal\"] = \"I\"\n            azint2d.attrs[\"axes\"] = [\".\", \"azimuthal_axis\", \"radial_axis\"]\n            azint2d.attrs[\"interpretation\"] = \"image\"\n            entry[\"data\"] = h5py.SoftLink('/entry/azint1d/data')\n            self.write_radial_axis(azint2d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n            dset = azint2d.create_dataset(\"azimuthal_axis\", data=self.ai.azimuth_axis)\n            dset.attrs[\"units\"] = \"degrees\"\n            dset.attrs[\"long_name\"] = \"azimuthal bin center\"\n\n            if isinstance(self.ai.azimuth_bins, Iterable):\n                aedges = self.ai.azimuth_bins\n            else:\n                acentres = self.ai.azimuth_axis\n                awidth = acentres[1] - acentres[0]\n                aedges = (acentres - 0.5 * awidth)\n                aedges = np.append(aedges, aedges[-1] + awidth)\n\n            dset2 = azint2d.create_dataset(\"azimuthal_axis_edges\", data=aedges)\n            dset2.attrs[\"units\"] = \"degrees\"\n            dset2.attrs[\"long_name\"] = \"azimuthal bin edges\"\n\n            azint1dSE.attrs[\"default\"] = \"data\"\n            azint2dSE.attrs[\"default\"] = \"data\"\n            entry.attrs[\"default\"] = \"data\"\n\n        elif self.write_1d:\n            logging.info(f\"Creating just 1D data ...\")\n            # ONLY 1D DATA section\n            reduction = entry.create_group(\"reduction\", track_order=True)\n            reduction.attrs[\"NX_class\"] = \"NXprocess\"\n            prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n            ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n            date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n            ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n            note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n            input = reduction.create_group(\"input\", track_order=True)\n            input.attrs[\"NX_class\"] = \"NXparameters\"\n            dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n            dset.attrs[\"filename\"] = poni_file\n            # Add wavelength and energy to mono\n            wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n            wavelength.attrs[\"units\"] = \"angstrom\"\n            energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n            energy.attrs[\"units\"] = \"keV\"\n\n            # Add other info from poni to input\n            wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)     \n            wavelength2.attrs[\"units\"] = \"angstrom\"\n\n            input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n            input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n            azimuth_bins = self.ai.azimuth_bins if self.ai.azimuth_bins else 1\n            input.create_dataset(\"azimuth_bins\", data=azimuth_bins)\n            input.create_dataset(\"unit\", data=self.ai.unit)\n            input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n            input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n            polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n            input.create_dataset(\"polarization_factor\", data=polarization)\n            error_model = self.ai.error_model if self.ai.error_model else \"None\"\n            input.create_dataset(\"error_model\", data=error_model)\n\n            azint1d = entry.create_group(\"data\", track_order=True)\n            azint1d.attrs[\"NX_class\"] = \"NXdata\"\n            azint1d.attrs[\"signal\"] = \"I\"\n            azint1d.attrs[\"axes\"] = [\".\", \"radial_axis\"]\n            azint1d.attrs[\"interpretation\"] = \"spectrum\"\n            self.write_radial_axis(azint1d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n\n            entry.attrs[\"default\"] = \"data\"\n\n        elif self.write_2d:\n            logging.info(f\"Creating just 2D data ...\")\n            # ONLY 2D DATA section\n            reduction = entry.create_group(\"reduction\", track_order=True)\n            reduction.attrs[\"NX_class\"] = \"NXprocess\"\n            prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n            ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n            date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n            ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n            note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n            input = reduction.create_group(\"input\", track_order=True)\n            input.attrs[\"NX_class\"] = \"NXparameters\"\n            dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n            dset.attrs[\"filename\"] = poni_file\n            # Add wavelength and energy to mono\n            wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n            wavelength.attrs[\"units\"] = \"angstrom\"\n            energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n            energy.attrs[\"units\"] = \"keV\"\n\n            # Add other info from poni to input\n            wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)     \n            wavelength2.attrs[\"units\"] = \"angstrom\"\n\n            input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n            input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n            azimuth_bins = self.ai.azimuth_bins\n            input.create_dataset(\"azimuth_bins\", data=azimuth_bins)\n            input.create_dataset(\"unit\", data=self.ai.unit)\n            input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n            input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n            polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n            input.create_dataset(\"polarization_factor\", data=polarization)\n            error_model = self.ai.error_model if self.ai.error_model else \"None\"\n            input.create_dataset(\"error_model\", data=error_model)\n\n            azint2d = entry.create_group(\"data\", track_order=True)\n            azint2d.attrs[\"NX_class\"] = \"NXdata\"\n            azint2d.attrs[\"signal\"] = \"I\"\n            azint2d.attrs[\"axes\"] = [\".\", \"azimuthal_axis\", \"radial_axis\"]\n            azint2d.attrs[\"interpretation\"] = \"image\"\n            self.write_radial_axis(azint2d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n            dset = azint2d.create_dataset(\"azimuthal_axis\", data=self.ai.azimuth_axis)\n            dset.attrs[\"units\"] = \"degrees\"\n            dset.attrs[\"long_name\"] = \"azimuthal bin center\"\n\n            if isinstance(self.ai.azimuth_bins, Iterable):\n                aedges = self.ai.azimuth_bins\n            else:\n                acentres = self.ai.azimuth_axis\n                awidth = acentres[1] - acentres[0]\n                aedges = (acentres - 0.5 * awidth)\n                aedges = np.append(aedges, aedges[-1] + awidth)\n\n            dset2 = azint2d.create_dataset(\"azimuthal_axis_edges\", data=aedges)\n            dset2.attrs[\"units\"] = \"degrees\"\n            dset2.attrs[\"long_name\"] = \"azimuthal bin edges\"\n\n            entry.attrs[\"default\"] = \"data\"\n\n    def add_data(self, integrated_data):\n        \"\"\"\n        Add azimuthal integration data to the HDF5 file under the proper NXdata group.\n\n        Parameters:\n        - integrated_data (tuple): Tuple of form (I, errors_1d, cake, errors_2d), where:\n            - I: 1D intensity array\n            - errors_1d: 1D error array\n            - cake: 2D intensity array\n            - errors_2d: 2D error array\n        \"\"\"\n\n        I, errors_1d, cake, errors_2d = integrated_data\n        data = {}\n        if (self.write_1d and self.write_2d):\n        # if cake is not None: # will have eta bins\n            data[\"/entry/azint1d/data/I\"] = I\n            data[\"/entry/azint2d/data/I\"] = cake\n            if self.ai.normalized:\n                data[\"/entry/azint2d/data/norm\"] = self.ai.norm_2d\n                data[\"/entry/azint1d/data/norm\"] = self.ai.norm_1d\n            if errors_2d is not None:\n                data[\"/entry/azint2d/data/I_errors\"] = errors_2d\n            if errors_1d is not None:\n                data[\"/entry/azint1d/data/I_errors\"] = errors_1d\n        elif self.write_1d:  # must be radial bins only, no eta, ie 1d.\n            data[\"/entry/data/I\"] = I\n            if self.ai.normalized:\n                data[\"/entry/data/norm\"] = self.ai.norm_1d\n            if errors_1d is not None:\n                data[\"/entry/data/I_errors\"] = errors_1d\n        elif self.write_2d:\n            data[\"/entry/data/I\"] = cake\n            if self.ai.normalized:\n                data[\"/entry/data/norm\"] = self.ai.norm_2d\n            if errors_2d is not None:\n                data[\"/entry/data/I_errors\"] = errors_2d\n        else:\n            logging.error(f\"At least one of 1D or 2D should be written\")\n\n        with h5py.File(self.output_file, \"r+\") as fh_u:\n            for key, value in data.items():\n                new_dset = fh_u.get(key)\n                if not new_dset:\n                    new_dset = fh_u.create_dataset(key, dtype=value.dtype,\n                                                   shape=(0, *value.shape),\n                                                   maxshape=(None, *value.shape),\n                                                   chunks=(1, *value.shape))\n                    # I and I_error created here\n                    new_dset.attrs[\"units\"] = \"arbitrary units\"\n                    new_dset.attrs[\"long_name\"] = \"intensity\"\n                    if \"I_error\" in key:\n                        new_dset.attrs.modify(\"long_name\", \"estimated errors on intensity\")\n                    if \"norm\" in key:\n                        new_dset.attrs.modify(\"long_name\", \"number of pixels contributing to the corresponding bin\")\n\n                n = new_dset.shape[0]\n                new_dset.resize(n + 1, axis=0)\n                new_dset[n] = value\n\n    def write_radial_axis(self, group, unit, radial_axis, radial_bins):\n        # real dataset for radial axis is always \"radial axis\"\n        dset = group.create_dataset(\"radial_axis\", data=radial_axis, track_order=True)\n        dset.attrs[\"long_name\"] = \"q\" if unit == \"q\" else \"2theta\"\n        dset.attrs[\"units\"] = \"1/angstrom\" if unit == \"q\" else \"degrees\"\n\n        # Calculate edges\n        if isinstance(radial_bins, Iterable):\n            edges = radial_bins\n        else:\n            centres = radial_axis\n            width = centres[1]-centres[0]\n            edges = (centres-0.5*width)\n            edges = np.append(edges,edges[-1]+width)\n\n        dsete = group.create_dataset(\"radial_axis_edges\", data=edges, track_order=True)\n        dsete.attrs[\"long_name\"] = \"q bin edges\" if unit == \"q\" else \"2theta bin edges\"\n        dsete.attrs[\"units\"] = \"1/angstrom\" if unit == \"q\" else \"degrees\"\n</code></pre>"},{"location":"class-reference/#azint_writer.azint_writer.NXWriter.add_data","title":"<code>add_data(integrated_data)</code>","text":"<p>Add azimuthal integration data to the HDF5 file under the proper NXdata group.</p> <ul> <li>integrated_data (tuple): Tuple of form (I, errors_1d, cake, errors_2d), where:<ul> <li>I: 1D intensity array</li> <li>errors_1d: 1D error array</li> <li>cake: 2D intensity array</li> <li>errors_2d: 2D error array</li> </ul> </li> </ul> Source code in <code>azint_writer/azint_writer.py</code> <pre><code>def add_data(self, integrated_data):\n    \"\"\"\n    Add azimuthal integration data to the HDF5 file under the proper NXdata group.\n\n    Parameters:\n    - integrated_data (tuple): Tuple of form (I, errors_1d, cake, errors_2d), where:\n        - I: 1D intensity array\n        - errors_1d: 1D error array\n        - cake: 2D intensity array\n        - errors_2d: 2D error array\n    \"\"\"\n\n    I, errors_1d, cake, errors_2d = integrated_data\n    data = {}\n    if (self.write_1d and self.write_2d):\n    # if cake is not None: # will have eta bins\n        data[\"/entry/azint1d/data/I\"] = I\n        data[\"/entry/azint2d/data/I\"] = cake\n        if self.ai.normalized:\n            data[\"/entry/azint2d/data/norm\"] = self.ai.norm_2d\n            data[\"/entry/azint1d/data/norm\"] = self.ai.norm_1d\n        if errors_2d is not None:\n            data[\"/entry/azint2d/data/I_errors\"] = errors_2d\n        if errors_1d is not None:\n            data[\"/entry/azint1d/data/I_errors\"] = errors_1d\n    elif self.write_1d:  # must be radial bins only, no eta, ie 1d.\n        data[\"/entry/data/I\"] = I\n        if self.ai.normalized:\n            data[\"/entry/data/norm\"] = self.ai.norm_1d\n        if errors_1d is not None:\n            data[\"/entry/data/I_errors\"] = errors_1d\n    elif self.write_2d:\n        data[\"/entry/data/I\"] = cake\n        if self.ai.normalized:\n            data[\"/entry/data/norm\"] = self.ai.norm_2d\n        if errors_2d is not None:\n            data[\"/entry/data/I_errors\"] = errors_2d\n    else:\n        logging.error(f\"At least one of 1D or 2D should be written\")\n\n    with h5py.File(self.output_file, \"r+\") as fh_u:\n        for key, value in data.items():\n            new_dset = fh_u.get(key)\n            if not new_dset:\n                new_dset = fh_u.create_dataset(key, dtype=value.dtype,\n                                               shape=(0, *value.shape),\n                                               maxshape=(None, *value.shape),\n                                               chunks=(1, *value.shape))\n                # I and I_error created here\n                new_dset.attrs[\"units\"] = \"arbitrary units\"\n                new_dset.attrs[\"long_name\"] = \"intensity\"\n                if \"I_error\" in key:\n                    new_dset.attrs.modify(\"long_name\", \"estimated errors on intensity\")\n                if \"norm\" in key:\n                    new_dset.attrs.modify(\"long_name\", \"number of pixels contributing to the corresponding bin\")\n\n            n = new_dset.shape[0]\n            new_dset.resize(n + 1, axis=0)\n            new_dset[n] = value\n</code></pre>"},{"location":"class-reference/#azint_writer.azint_writer.NXWriter.write_header","title":"<code>write_header()</code>","text":"<p>Creates and writes the NeXus hierarchy for the dataset, including metadata such as instrument configuration,  source details, monochromator properties, and integration parameters.</p> <p>This method will automatically determine what type(s) of data  (1D/2D) are to be written and populate corresponding subentries.</p> Source code in <code>azint_writer/azint_writer.py</code> <pre><code>def write_header(self):\n    \"\"\"\n    Creates and writes the NeXus hierarchy for the dataset,\n    including metadata such as instrument configuration, \n    source details, monochromator properties, and integration parameters.\n\n    This method will automatically determine what type(s) of data \n    (1D/2D) are to be written and populate corresponding subentries.\n    \"\"\"\n    logging.info(f\"writing header started, azint version is {azint.__version__}\")\n\n    entry = self.fh.create_group(\"entry\", track_order=True)\n    entry.attrs[\"NX_class\"] = \"NXentry\"\n    entry.attrs[\"default\"] = \"data\" \n    logging.debug(\"entry is created in the file\")\n\n\n    if not (self.write_1d and self.write_2d):\n        logging.info(f\"Creating {'NXazint1d' if self.write_1d else 'NXazint2d'}\")\n        definition = entry.create_dataset(\"definition\", data='NXazint1d' if self.write_1d else 'NXazint2d')       \n\n    solid_angle = entry.create_dataset(\"solid_angle_applied\", data=True if self.ai.solid_angle else False)\n\n    polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n    polarization_applied = entry.create_dataset(\"polarization_applied\", data=True if self.ai.polarization_factor  is not None else False)\n\n    normalization = entry.create_dataset(\"normalization_applied\", data=True if self.ai.normalized else False)\n\n    logging.info(\"solid_angle_applied and polarization_applied data sets are created\")\n    logging.info(f\"solid_angle: {self.ai.solid_angle}\")\n    logging.info(f\"polarization_factor: {self.ai.polarization_factor}\")\n\n\n    # Add instrument\n    instrument = entry.create_group(\"instrument\", track_order=True)\n    instrument.attrs[\"NX_class\"] = \"NXinstrument\"\n    instrument.attrs[\"default\"] = \"name\" \n    logging.info(f\"Instrument: {self.instrument_name}\")\n\n    instrument[\"name\"] = np.string_(self.instrument_name)\n\n    # Add monochromator\n    mono = instrument.create_group(\"monochromator\", track_order=True)\n    mono.attrs[\"NX_class\"] = \"NXmonochromator\"\n    mono.attrs[\"default\"] = \"energy\"  \n\n    # Add source\n    source = instrument.create_group(\"source\", track_order=True)\n    source.attrs[\"NX_class\"] = \"NXsource\"\n    source.attrs[\"default\"] = \"name\" \n    source['name'] = self.source_name\n    source['type'] = self.source_type\n    source['probe'] = self.source_probe\n\n    poni_file = self.ai.poni\n    if isinstance(self.ai.poni, str):\n        with open(poni_file, \"r\") as pf:\n            try:\n                logging.info(f\"Reading poni file ...\")\n                ponif = pf.read()\n                wavelength_found = False\n                for line in ponif.splitlines():\n                    if line.startswith(\"Wavelength:\"):\n                        wlength_str = line.split(\":\")[1].strip()\n                        try:\n                            wlength = float(wlength_str)\n                            logging.info(f\"From poni file: wavelength: {wlength * 1e10} \u212b\")\n                            wavelength_found = True\n                        except ValueError as e:\n                            logging.error(f\"Error converting wavelength to float: {e}\")\n                            wlength = None\n                        break\n                if not wavelength_found:\n                    logging.error(\"Wavelength not found in poni file.\")\n                    wlength = None\n            except Exception as e:\n                logging.error(f\"Cannot open poni file: {e}\")\n    elif isinstance(self.ai.poni, dict):\n        ponif = \"\\n\".join(f\"{key}: {value}\" for key, value in self.ai.poni.items())\n        wavelength_found = False\n        try:\n            wlength = float(self.ai.poni['wavelength'])\n            logging.info(f\"From poni file: wavelength: {wlength * 1e10} \u212b\")\n            wavelength_found = True\n        except ValueError as e:\n            logging.error(f\"Error converting wavelength to float: {e}\")\n            wlength = None\n        if not wavelength_found:\n            logging.error(\"Wavelength not found in poni dict.\")\n            wlength = None\n    else:\n        logging.error(\"Provided format for poni is wrong.\")\n\n    # Now handle data splitting\n    if (self.write_1d and self.write_2d):\n        logging.info(f\"Creating 1D and 2D data ...\")\n        if self.ai.azimuth_axis is None:\n            logging.error(\"2d data is not available.\")\n        # 1D data subentry\n        azint1dSE = entry.create_group(\"azint1d\", track_order=True)\n        azint1dSE.attrs[\"NX_class\"] = \"NXsubentry\"\n\n        definition = azint1dSE.create_dataset(\"definition\", data=\"NXazint1d\")\n\n        azint1dSE[\"instrument\"] = h5py.SoftLink('/entry/instrument')\n\n        reduction = azint1dSE.create_group(\"reduction\", track_order=True)\n        reduction.attrs[\"NX_class\"] = \"NXprocess\"\n        prog = reduction.create_dataset(\"program\", data=\"azint\")\n        ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n        date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n        ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n        note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n        input = reduction.create_group(\"input\", track_order=True)\n        input.attrs[\"NX_class\"] = \"NXparameters\"\n        dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n        dset.attrs[\"filename\"] = poni_file if isinstance(self.ai.poni, str) else \"Poni dict.\"\n\n        wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n        wavelength.attrs[\"units\"] = \"angstrom\"\n        energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n        energy.attrs[\"units\"] = \"keV\"\n\n        wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)\n        wavelength2.attrs[\"units\"] = \"angstrom\"\n\n        input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n        input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n        input.create_dataset(\"azimuth_bins\", data=1)\n        input.create_dataset(\"unit\", data=self.ai.unit)    \n        input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n        input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n        polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n        input.create_dataset(\"polarization_factor\", data=polarization)\n        error_model = self.ai.error_model if self.ai.error_model else \"None\"\n        input.create_dataset(\"error_model\", data=error_model)\n\n\n        azint1d = azint1dSE.create_group(\"data\")\n        azint1d.attrs[\"NX_class\"] = \"NXdata\"\n        azint1d.attrs[\"signal\"] = \"I\"\n        azint1d.attrs[\"axes\"] = [\".\", \"radial_axis\"]\n        azint1d.attrs[\"interpretation\"] = \"spectrum\"\n        self.write_radial_axis(azint1d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n\n        azint2dSE = entry.create_group(\"azint2d\", track_order=True)\n        azint2dSE.attrs[\"NX_class\"] = \"NXsubentry\"\n\n        definition = azint2dSE.create_dataset(\"definition\", data=\"NXazint2d\")\n\n        azint2dSE[\"instrument\"] = h5py.SoftLink('/entry/instrument')\n\n        reduction = azint2dSE.create_group(\"reduction\", track_order=True)\n        reduction.attrs[\"NX_class\"] = \"NXprocess\"\n        prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n        ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n        date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n        ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n        note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n        input = reduction.create_group(\"input\", track_order=True)\n        input.attrs[\"NX_class\"] = \"NXparameters\"\n\n        wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)\n        wavelength2.attrs[\"units\"] = \"angstrom\"\n\n        input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n        input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n        input.create_dataset(\"azimuth_bins\", data=self.ai.azimuth_bins)\n        input.create_dataset(\"unit\", data=self.ai.unit)\n        input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n        input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n        polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n        input.create_dataset(\"polarization_factor\", data=polarization)\n        error_model = self.ai.error_model if self.ai.error_model else \"None\"\n        input.create_dataset(\"error_model\", data=error_model)\n\n        azint2d = azint2dSE.create_group(\"data\")\n        azint2d.attrs[\"NX_class\"] = \"NXdata\"\n        azint2d.attrs[\"signal\"] = \"I\"\n        azint2d.attrs[\"axes\"] = [\".\", \"azimuthal_axis\", \"radial_axis\"]\n        azint2d.attrs[\"interpretation\"] = \"image\"\n        entry[\"data\"] = h5py.SoftLink('/entry/azint1d/data')\n        self.write_radial_axis(azint2d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n        dset = azint2d.create_dataset(\"azimuthal_axis\", data=self.ai.azimuth_axis)\n        dset.attrs[\"units\"] = \"degrees\"\n        dset.attrs[\"long_name\"] = \"azimuthal bin center\"\n\n        if isinstance(self.ai.azimuth_bins, Iterable):\n            aedges = self.ai.azimuth_bins\n        else:\n            acentres = self.ai.azimuth_axis\n            awidth = acentres[1] - acentres[0]\n            aedges = (acentres - 0.5 * awidth)\n            aedges = np.append(aedges, aedges[-1] + awidth)\n\n        dset2 = azint2d.create_dataset(\"azimuthal_axis_edges\", data=aedges)\n        dset2.attrs[\"units\"] = \"degrees\"\n        dset2.attrs[\"long_name\"] = \"azimuthal bin edges\"\n\n        azint1dSE.attrs[\"default\"] = \"data\"\n        azint2dSE.attrs[\"default\"] = \"data\"\n        entry.attrs[\"default\"] = \"data\"\n\n    elif self.write_1d:\n        logging.info(f\"Creating just 1D data ...\")\n        # ONLY 1D DATA section\n        reduction = entry.create_group(\"reduction\", track_order=True)\n        reduction.attrs[\"NX_class\"] = \"NXprocess\"\n        prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n        ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n        date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n        ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n        note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n        input = reduction.create_group(\"input\", track_order=True)\n        input.attrs[\"NX_class\"] = \"NXparameters\"\n        dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n        dset.attrs[\"filename\"] = poni_file\n        # Add wavelength and energy to mono\n        wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n        wavelength.attrs[\"units\"] = \"angstrom\"\n        energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n        energy.attrs[\"units\"] = \"keV\"\n\n        # Add other info from poni to input\n        wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)     \n        wavelength2.attrs[\"units\"] = \"angstrom\"\n\n        input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n        input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n        azimuth_bins = self.ai.azimuth_bins if self.ai.azimuth_bins else 1\n        input.create_dataset(\"azimuth_bins\", data=azimuth_bins)\n        input.create_dataset(\"unit\", data=self.ai.unit)\n        input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n        input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n        polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n        input.create_dataset(\"polarization_factor\", data=polarization)\n        error_model = self.ai.error_model if self.ai.error_model else \"None\"\n        input.create_dataset(\"error_model\", data=error_model)\n\n        azint1d = entry.create_group(\"data\", track_order=True)\n        azint1d.attrs[\"NX_class\"] = \"NXdata\"\n        azint1d.attrs[\"signal\"] = \"I\"\n        azint1d.attrs[\"axes\"] = [\".\", \"radial_axis\"]\n        azint1d.attrs[\"interpretation\"] = \"spectrum\"\n        self.write_radial_axis(azint1d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n\n        entry.attrs[\"default\"] = \"data\"\n\n    elif self.write_2d:\n        logging.info(f\"Creating just 2D data ...\")\n        # ONLY 2D DATA section\n        reduction = entry.create_group(\"reduction\", track_order=True)\n        reduction.attrs[\"NX_class\"] = \"NXprocess\"\n        prog = reduction.create_dataset(\"program\", data=\"azint-pipeline\")\n        ver = reduction.create_dataset(\"version\", data=f\"azint {azint.__version__}\\nazint-writer {__version__}\")\n        date = reduction.create_dataset(\"date\", data=datetime.now().strftime(\"%A, %B %d, %Y at %I:%M %p\"))\n        ref = reduction.create_dataset(\"reference\", data=\"Jensen, A. B., et al., (2022). J. Synchrotron Rad. 29, 1420-1428.\\nhttps://doi.org/10.1107/S1600577522008232,\\nhttps://maxiv-science.github.io/azint/\")\n        note = reduction.create_dataset(\"note\", data=\"Geometry convention:\\nAzimuthal origin in the horizontal plane to the right of the beam position, i.e., at 3 o\u2019clock,\\non the detector face. Positive azimuthal direction: clockwise.\")\n\n        input = reduction.create_group(\"input\", track_order=True)\n        input.attrs[\"NX_class\"] = \"NXparameters\"\n        dset = input.create_dataset(\"poni\", data=ponif, track_order=True)\n        dset.attrs[\"filename\"] = poni_file\n        # Add wavelength and energy to mono\n        wavelength = mono.create_dataset(\"wavelength\", data=wlength * 1e10, track_order=True)\n        wavelength.attrs[\"units\"] = \"angstrom\"\n        energy = mono.create_dataset(\"energy\", data=(1.2398 * 1e-9) / wlength, track_order=True)\n        energy.attrs[\"units\"] = \"keV\"\n\n        # Add other info from poni to input\n        wavelength2 = input.create_dataset(\"wavelength\", data=wlength * 1e10)     \n        wavelength2.attrs[\"units\"] = \"angstrom\"\n\n        input.create_dataset(\"n_splitting\", data=self.ai.n_splitting)\n        input.create_dataset(\"radial_bins\", data=self.ai.radial_bins)\n        azimuth_bins = self.ai.azimuth_bins\n        input.create_dataset(\"azimuth_bins\", data=azimuth_bins)\n        input.create_dataset(\"unit\", data=self.ai.unit)\n        input.create_dataset(\"mask\", data=self.ai.mask_path if self.ai.mask_path else (\"A numpy array was provided\" if self.ai.mask is not None else \"None\"))\n\n        input.create_dataset(\"solid_angle\", data=True if self.ai.solid_angle else False)\n\n        polarization = self.ai.polarization_factor if self.ai.polarization_factor is not None else 0\n        input.create_dataset(\"polarization_factor\", data=polarization)\n        error_model = self.ai.error_model if self.ai.error_model else \"None\"\n        input.create_dataset(\"error_model\", data=error_model)\n\n        azint2d = entry.create_group(\"data\", track_order=True)\n        azint2d.attrs[\"NX_class\"] = \"NXdata\"\n        azint2d.attrs[\"signal\"] = \"I\"\n        azint2d.attrs[\"axes\"] = [\".\", \"azimuthal_axis\", \"radial_axis\"]\n        azint2d.attrs[\"interpretation\"] = \"image\"\n        self.write_radial_axis(azint2d, self.ai.unit, self.ai.radial_axis, self.ai.radial_bins)\n        dset = azint2d.create_dataset(\"azimuthal_axis\", data=self.ai.azimuth_axis)\n        dset.attrs[\"units\"] = \"degrees\"\n        dset.attrs[\"long_name\"] = \"azimuthal bin center\"\n\n        if isinstance(self.ai.azimuth_bins, Iterable):\n            aedges = self.ai.azimuth_bins\n        else:\n            acentres = self.ai.azimuth_axis\n            awidth = acentres[1] - acentres[0]\n            aedges = (acentres - 0.5 * awidth)\n            aedges = np.append(aedges, aedges[-1] + awidth)\n\n        dset2 = azint2d.create_dataset(\"azimuthal_axis_edges\", data=aedges)\n        dset2.attrs[\"units\"] = \"degrees\"\n        dset2.attrs[\"long_name\"] = \"azimuthal bin edges\"\n\n        entry.attrs[\"default\"] = \"data\"\n</code></pre>"}]}